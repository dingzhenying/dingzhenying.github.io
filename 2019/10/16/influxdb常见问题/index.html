<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="一只快乐的小怪兽" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    influxdb常见问题 |  iMonster
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="iMonster" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-influxdb常见问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  influxdb常见问题
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/10/16/influxdb%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2019-10-16T07:23:16.000Z" itemprop="datePublished">2019-10-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-influxdb/">数据库\influxdb</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">35 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>管理（Administration）</strong></p>
<ul>
<li>如何识别TSDB For InfluxDB®的版本？</li>
<li>shard group duration和保留策略之间的关系是什么？</li>
<li>当更改保留策略后，为什么数据没有丢失？</li>
<li>为什么TSDB For InfluxDB®无法解析微秒单位？</li>
</ul>
<p><strong>命令行界面（CLI）</strong></p>
<ul>
<li>如何使TSDB For InfluxDB®的CLI返回用户可读的时间戳？</li>
<li>非admin用户如何使用<code>USE</code>指定一个数据库？</li>
<li>如何使用TSDB For InfluxDB®的CLI将数据写入一个非默认的保留策略</li>
</ul>
<a id="more"></a>
<p><strong>数据类型</strong></p>
<ul>
<li>为什么不能查询布尔类型的field value？</li>
<li>TSDB For InfluxDB®如何处理多个shard之间的field的类型差异？</li>
<li>TSDB For InfluxDB®可以存储的最小和最大整数是多少？</li>
<li>TSDB For InfluxDB®可以存储的最小和最大时间戳是多少？</li>
<li>如何知道存储在field中的数据类型？</li>
<li>是否可以改变field的数据类型？</li>
</ul>
<p><strong>InfluxQL函数</strong></p>
<ul>
<li>如何执行函数中的数学运算？</li>
<li>为什么查询将epoch 0作为时间戳返回？</li>
<li>哪些InfluxQL函数支持嵌套使用？</li>
</ul>
<p><strong>查询数据</strong></p>
<ul>
<li>什么决定了<code>GROUP BY time()</code>查询返回的时间间隔？</li>
<li>为什么查询没有返回任何数据或者只返回一部分数据？</li>
<li>为什么<code>GROUP BY time()</code>查询不返回发生在<code>now()</code>之后的时间戳？</li>
<li>是否可以对时间戳执行数学运算？</li>
<li>是否可以从返回的时间戳中识别写入精度？</li>
<li>当查询数据时，什么时候应该使用单引号，什么时候应该使用双引号？</li>
<li>为什么在创建一个新的默认（<code>DEFAULT</code>）保留策略后会丢失数据？</li>
<li>为什么带有<code>WHERE OR</code>时间子句的查询返回空结果？</li>
<li>为什么<code>fill(previous)</code>返回空结果？</li>
<li>为什么<code>INTO</code>查询会丢失数据？</li>
<li>如何查询tag key和field key名字相同的数据？</li>
<li>如何跨measurement查询数据？</li>
<li>时间戳的顺序是否重要？</li>
<li>如何<code>SELECT</code>有tag但没有tag value的数据？</li>
</ul>
<p><strong>序列和序列基数</strong></p>
<ul>
<li>为什么序列基数很重要？</li>
</ul>
<p><strong>写入数据</strong></p>
<ul>
<li>如何写入整型的field value？</li>
<li>TSDB For InfluxDB®如何处理重复数据点？</li>
<li>HTTP API需要怎样的换行符？</li>
<li>当将数据写入TSDB For InfluxDB®时，应该避免哪些文字和字符？</li>
<li>当写入数据时，什么时候应该使用单引号，什么时候应该使用双引号？</li>
<li>时间戳的精度是否重要？</li>
</ul>
<h1 id="如何识别TSDB-For-InfluxDB®的版本？"><a href="#如何识别TSDB-For-InfluxDB®的版本？" class="headerlink" title="如何识别TSDB For InfluxDB®的版本？"></a>如何识别TSDB For InfluxDB®的版本？</h1><p>有多种方法可以识别您正在使用的TSDB For InfluxDB®版本：</p>
<h2 id="curl路径-ping"><a href="#curl路径-ping" class="headerlink" title="curl路径/ping"></a><code>curl</code>路径<code>/ping</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i &#39;https:&#x2F;&#x2F;&lt;网络地址&gt;:3242&#x2F;ping?u&#x3D;&lt;账号名称&gt;&amp;p&#x3D;&lt;密码&gt;&#39;HTTP&#x2F;1.1 204 No ContentContent-Type: application&#x2F;jsonX-Influxdb-Build: OSSX-Influxdb-Version: 1.7.x</span><br></pre></td></tr></table></figure>

<h2 id="启动TSDB-For-InfluxDB®的命令行界面："><a href="#启动TSDB-For-InfluxDB®的命令行界面：" class="headerlink" title="启动TSDB For InfluxDB®的命令行界面："></a>启动TSDB For InfluxDB®的命令行界面：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ influx -ssl -username &lt;账号名称&gt; -password &lt;密码&gt; -host &lt;网络地址&gt; -port 3242Connected to https:&#x2F;&#x2F;&lt;网络地址&gt;:3242 version 1.7.x</span><br></pre></td></tr></table></figure>

<h1 id="shard-group-duration和保留策略之间的关系是什么？"><a href="#shard-group-duration和保留策略之间的关系是什么？" class="headerlink" title="shard group duration和保留策略之间的关系是什么？"></a>shard group duration和保留策略之间的关系是什么？</h1><p>TSDB For InfluxDB®将数据存储在shard group。一个shard group覆盖一个特定的时间间隔；TSDB For InfluxDB®通过查看相关保留策略的<code>DURATION</code>来确定时间间隔。下表列出了RP的<code>DURATION</code>和一个shard group的时间间隔之间的默认关系：</p>
<table>
<thead>
<tr>
<th align="left">RP持续时间（duration）</th>
<th align="left">Shard group时间间隔</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&lt; 2 days</td>
<td align="left">1 hour</td>
</tr>
<tr>
<td align="left">&gt;= 2 days and &lt;= 6 months</td>
<td align="left">1 day</td>
</tr>
<tr>
<td align="left">&gt; 6 months</td>
<td align="left">7 days</td>
</tr>
</tbody></table>
<p>使用<code>SHOW RETENTION POLICIES</code>查看保留策略的shard group duration。</p>
<h1 id="当更改保留策略后，为什么数据没有丢失？"><a href="#当更改保留策略后，为什么数据没有丢失？" class="headerlink" title="当更改保留策略后，为什么数据没有丢失？"></a>当更改保留策略后，为什么数据没有丢失？</h1><p>有几个原因可以解释为什么保留策略改变后数据没有马上丢失。</p>
<p>第一个也是最有可能的原因是，默认情况下，TSDB For InfluxDB®每30分钟检查并强制执行一次RP。您可能需要等到下一次RP检查，TSDB For InfluxDB®才能删除在RP的新<code>DURATION</code>之外的数据。</p>
<p>第二个可能的原因是，更改RP的<code>DURATION</code>和<code>SHARD DURATION</code>会导致意外的数据保留。TSDB For InfluxDB®将数据存储在shard group，每个shard group覆盖一个特定的RP和时间间隔。当TSDB For InfluxDB®强制执行RP时，整个shard group的数据会被删除，而不是单个数据点。TSDB For InfluxDB®不能拆分shard group。</p>
<p>如果RP的新<code>DURATION</code>小于旧的<code>SHARD DURATION</code>，并且TSDB For InfluxDB®正在将数据写入一个旧的、<code>DURATION</code>较长的shard group，那么系统将强制把所有数据存储在该shard group中，即使该shard group中有些数据已经在新的<code>DURATION</code>之外。一旦shard group中所有数据都在新的<code>DURATION</code>之外，TSDB For InfluxDB®将会删除整个shard group，然后系统开始将数据写入具有新的、更短<code>SHARD DURATION</code>的shard group，避免进一步意想不到的数据保留。</p>
<h1 id="为什么TSDB-For-InfluxDB®无法解析微秒单位？"><a href="#为什么TSDB-For-InfluxDB®无法解析微秒单位？" class="headerlink" title="为什么TSDB For InfluxDB®无法解析微秒单位？"></a>为什么TSDB For InfluxDB®无法解析微秒单位？</h1><p>在不同场景下：写入、查询以及在TSDB For InfluxDB®命令行界面（CLI）设置精度，用于指定微秒时间单位的语法也不同。下表显示了每个类别支持的语法：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">使用HTTP API写入数据</th>
<th align="left">所有查询</th>
<th align="left">在CLI设置精度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">u</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">us</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
</tr>
<tr>
<td align="left">µ</td>
<td align="left">❌</td>
<td align="left">√</td>
<td align="left">❌</td>
</tr>
<tr>
<td align="left">µs</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
</tr>
</tbody></table>
<h1 id="如何使TSDB-For-InfluxDB®的CLI返回用户可读的时间戳？"><a href="#如何使TSDB-For-InfluxDB®的CLI返回用户可读的时间戳？" class="headerlink" title="如何使TSDB For InfluxDB®的CLI返回用户可读的时间戳？"></a>如何使TSDB For InfluxDB®的CLI返回用户可读的时间戳？</h1><p>在您首次连接CLI时，请指定<a href="https://www.ietf.org/rfc/rfc3339.txt" target="_blank" rel="noopener">rfc3339</a>精度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ influx -ssl -username &lt;账号名称&gt; -password &lt;密码&gt; -host &lt;网络地址&gt; -port 3242 -precision rfc3339</span><br></pre></td></tr></table></figure>

<p>或者，在连接CLI后指定精度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ influx -ssl -username &lt;账号名称&gt; -password &lt;密码&gt; -host &lt;网络地址&gt; -port 3242Connected to https:&#x2F;&#x2F;&lt;网络地址&gt;:3242 version 1.7.x&gt; precision rfc3339&gt;</span><br></pre></td></tr></table></figure>

<p>请查看文档<a href="https://help.aliyun.com/document_detail/113114.html" target="_blank" rel="noopener">命令行界面</a>了解更多有用的CLI选项。</p>
<h1 id="非admin用户如何使用USE指定一个数据库？"><a href="#非admin用户如何使用USE指定一个数据库？" class="headerlink" title="非admin用户如何使用USE指定一个数据库？"></a>非admin用户如何使用<code>USE</code>指定一个数据库？</h1><p>如果非admin用户拥有数据库的<code>READ</code>和/或<code>WRITE</code>权限，那么可以执行<code>USE &lt;database_name&gt;</code>语句。如果非admin用户尝试用<code>USE</code>指定一个他们没有<code>READ</code>和/或<code>WRITE</code>权限的数据库，那么系统会返回错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERR: Database &lt;database_name&gt; doesn&#39;t exist. Run SHOW DATABASES for a list of existing databases.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注释：<code>SHOW DATABASES</code>查询只返回那些非admin用户有<code>READ</code>和/或<code>WRITE</code>权限的数据库。</p>
</blockquote>
<h1 id="如何使用TSDB-For-InfluxDB®的CLI将数据写入一个非默认的保留策略"><a href="#如何使用TSDB-For-InfluxDB®的CLI将数据写入一个非默认的保留策略" class="headerlink" title="如何使用TSDB For InfluxDB®的CLI将数据写入一个非默认的保留策略"></a>如何使用TSDB For InfluxDB®的CLI将数据写入一个非默认的保留策略</h1><p>请使用语法<code>INSERT INTO [&lt;database&gt;.]&lt;retention_policy&gt; &lt;line_protocol&gt;</code>将数据写入一个非默认的保留策略。（只允许在CLI中使用这种方式指定数据库和保留策略。如果通过HTTP写入数据，必须使用参数<code>db</code>和<code>rp</code>分别指定数据库和保留策略，指定保留策略是可选的。）</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; INSERT INTO one_day mortality bool&#x3D;trueUsing retention policy one_day&gt; SELECT * FROM &quot;mydb&quot;.&quot;one_day&quot;.&quot;mortality&quot;name: mortality---------------time                             bool2016-09-13T22:29:43.229530864Z   true</span><br></pre></td></tr></table></figure>

<p>请注意，您需要完全限定measurement来查询非默认保留策略中的数据。使用以下语法完全限定measurement：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;database&gt;&quot;.&quot;&lt;retention_policy&gt;&quot;.&quot;&lt;measurement&gt;&quot;</span><br></pre></td></tr></table></figure>

<h1 id="为什么不能查询布尔类型的field-value？"><a href="#为什么不能查询布尔类型的field-value？" class="headerlink" title="为什么不能查询布尔类型的field value？"></a>为什么不能查询布尔类型的field value？</h1><p>写入和查询布尔值的语法不一样。</p>
<table>
<thead>
<tr>
<th align="left">布尔值语法</th>
<th align="left">写入</th>
<th align="left">查询</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>t</code>,<code>f</code></td>
<td align="left">√</td>
<td align="left">❌</td>
</tr>
<tr>
<td align="left"><code>T</code>,<code>F</code></td>
<td align="left">√</td>
<td align="left">❌</td>
</tr>
<tr>
<td align="left"><code>true</code>,<code>false</code></td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left"><code>True</code>,<code>False</code></td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left"><code>TRUE</code>,<code>FALSE</code></td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
</tbody></table>
<p>例如，<code>SELECT * FROM &quot;hamlet&quot; WHERE &quot;bool&quot;=True</code>返回所有<code>bool</code>等于<code>TRUE</code>的数据点，但是，<code>SELECT * FROM &quot;hamlet&quot; WHERE &quot;bool&quot;=T</code>不会返回任何结果。</p>
<h1 id="TSDB-For-InfluxDB®如何处理多个shard之间的field的类型差异？"><a href="#TSDB-For-InfluxDB®如何处理多个shard之间的field的类型差异？" class="headerlink" title="TSDB For InfluxDB®如何处理多个shard之间的field的类型差异？"></a>TSDB For InfluxDB®如何处理多个shard之间的field的类型差异？</h1><p>field value可以是浮点数、整数、字符串或者布尔值。在一个shard里面，field value的数据类型不能不一样，但是在不同的shard，field value的数据类型可以不同。</p>
<h2 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h2><p><code>SELECT</code>语句返回所有的field value<strong>如果</strong>这些值有相同的数据类型。如果在不同的shard里面field value的数据类型不一样，那么TSDB For InfluxDB®首先会执行类型转换（如果适用的话），然后返回所有值，并且按以下数据类型的顺序返回结果：浮点数，整数，字符串，布尔值。</p>
<p>如果在您的数据中，field value的类型不同，请使用语法<code>&lt;field_key&gt;::&lt;type&gt;</code>查询不同的数据类型。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>measurement <code>just_my_type</code>有一个名为<code>my_field</code>的field，<code>my_field</code>在四个不同的shard中有四个field value，并且每个field value的数据类型不一样（分别是浮点数、整数、字符串和布尔值）。</p>
<p><code>SELECT *</code>只返回浮点型和整型的field value。请注意，在返回结果中TSDB For InfluxDB®强制将整数转换成浮点数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM just_my_typename: just_my_type------------------time                      my_field2016-06-03T15:45:00Z      9.870342016-06-03T16:45:00Z      7</span><br></pre></td></tr></table></figure>

<p><code>SELECT &lt;field_key&gt;::&lt;type&gt; [...]</code>返回所有数据类型。TSDB For InfluxDB®将每种类型的数据输出到单独的列中，并且使用递增的列名表示。在可能的情况下，TSDB For InfluxDB®将field value转换成另一种数据类型；它将整数<code>7</code>转换成第一列中的浮点数，将浮点数<code>9.879034</code>转换成第二列中的整数。TSDB For InfluxDB®不能将浮点数或整数转换成字符串或布尔值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT &quot;my_field&quot;::float,&quot;my_field&quot;::integer,&quot;my_field&quot;::string,&quot;my_field&quot;::boolean FROM just_my_typename: just_my_type------------------time                   my_field  my_field_1  my_field_2  my_field_32016-06-03T15:45:00Z   9.87034   92016-06-03T16:45:00Z   7         72016-06-03T17:45:00Z                         a string2016-06-03T18:45:00Z                                     true</span><br></pre></td></tr></table></figure>

<h2 id="SHOW-FIELD-KEYS查询"><a href="#SHOW-FIELD-KEYS查询" class="headerlink" title="SHOW FIELD KEYS查询"></a>SHOW FIELD KEYS查询</h2><p><code>SHOW FIELD KEYS</code>返回field key对应的每个shard中的每种数据类型。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>measurement <code>just_my_type</code>有一个名为<code>my_field</code>的field，<code>my_field</code>在四个不同的shard中有四个field value，并且每个field value的数据类型不一样（分别是浮点数、整数、字符串和布尔值）。</p>
<p><code>SHOW FIELD KEYS</code>返回所有四种数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SHOW FIELD KEYSname: just_my_typefieldKey   fieldType--------   ---------my_field   floatmy_field   stringmy_field   integermy_field   boolean</span><br></pre></td></tr></table></figure>

<h1 id="TSDB-For-InfluxDB®可以存储的最小和最大整数是多少？"><a href="#TSDB-For-InfluxDB®可以存储的最小和最大整数是多少？" class="headerlink" title="TSDB For InfluxDB®可以存储的最小和最大整数是多少？"></a>TSDB For InfluxDB®可以存储的最小和最大整数是多少？</h1><p>TSDB For InfluxDB®将所有整数存储为有符号的int64数据类型。int64有效的最小和最大值分别是<code>-9023372036854775808</code>和<code>9023372036854775807</code>。请查看<a href="http://golang.org/pkg/builtin/#int64" target="_blank" rel="noopener">Go builtins</a>获得更多相关信息。</p>
<p>使用接近最小/最大整数但依旧在限制范围内的值可能会导致非预期的结果；有些函数和运算符会在计算过程中将数据类型int64转换成float64，这会引起溢出问题。</p>
<h1 id="TSDB-For-InfluxDB®可以存储的最小和最大时间戳是多少？"><a href="#TSDB-For-InfluxDB®可以存储的最小和最大时间戳是多少？" class="headerlink" title="TSDB For InfluxDB®可以存储的最小和最大时间戳是多少？"></a>TSDB For InfluxDB®可以存储的最小和最大时间戳是多少？</h1><p>最小的时间戳是<code>-9223372036854775806</code>或<code>1677-09-21T00:12:43.145224194Z</code>，最大的时间戳是<code>9223372036854775806</code>或<code>2262-04-11T23:47:16.854775806Z</code>。超出该范围的时间戳会返回解析错误。</p>
<h1 id="如何知道存储在field中的数据类型？"><a href="#如何知道存储在field中的数据类型？" class="headerlink" title="如何知道存储在field中的数据类型？"></a>如何知道存储在field中的数据类型？</h1><p><code>SHOW FIELD KEYS</code>查询还返回field的数据类型。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SHOW FIELD KEYS FROM all_the_typesname: all_the_types-------------------fieldKey  fieldTypeblue      stringgreen     booleanorange    integeryellow    float</span><br></pre></td></tr></table></figure>

<h1 id="是否可以改变field的数据类型？"><a href="#是否可以改变field的数据类型？" class="headerlink" title="是否可以改变field的数据类型？"></a>是否可以改变field的数据类型？</h1><p>目前，在改变field的数据类型上面，TSDB For InfluxDB®提供非常有限的支持。语法<code>&lt;field_key&gt;::&lt;type&gt;</code>支持将field value从整数转换为浮点数或者从浮点数转换为整数。请查看文档<a href="https://help.aliyun.com/document_detail/113131.html" target="_blank" rel="noopener">数据探索</a>获得更多关于转换操作的信息。无法将浮点数或整数转换为字符串或布尔值（反之亦然）。</p>
<p>我们列出了可用于更改field数据类型的方法：</p>
<h2 id="将数据写入一个不同的field"><a href="#将数据写入一个不同的field" class="headerlink" title="将数据写入一个不同的field"></a>将数据写入一个不同的field</h2><p>最简单的解决方法就是将具有新数据类型的数据写入到同一个序列中的不同field。</p>
<h2 id="使用shard系统"><a href="#使用shard系统" class="headerlink" title="使用shard系统"></a>使用shard系统</h2><p>在一个shard里面，field value的数据类型不能不一样，但是在不同的shard，field value的数据类型可以不同。</p>
<p>如果要更改field的数据类型，用户可以使用<code>SHOW SHARDS</code>查询来识别当前shard的<code>end_time</code>。如果数据点的时间戳发生在<code>end_time</code>之后，那么TSDB For InfluxDB®允许将不同数据类型的数据写入到一个现有的field中（例如，field原来接受整数，但是在<code>end_time</code>之后，该field可以接受浮点数）。</p>
<p>请注意，这不会改变原来shard里面field的数据类型。</p>
<h1 id="如何执行函数中的数学运算？"><a href="#如何执行函数中的数学运算？" class="headerlink" title="如何执行函数中的数学运算？"></a>如何执行函数中的数学运算？</h1><p>目前，TSDB For InfluxDB®不支持函数内的数学运算。我们建议使用子查询作为解决方法。</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>InfluxQL不支持以下语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MEAN(&quot;dogs&quot; - &quot;cats&quot;) from &quot;pet_daycare&quot;</span><br></pre></td></tr></table></figure>

<p>相反，我们可以使用子查询获得相同的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MEAN(&quot;difference&quot;) FROM (SELECT &quot;dogs&quot; - &quot;cat&quot; AS &quot;difference&quot; FROM &quot;pet_daycare&quot;)</span><br></pre></td></tr></table></figure>

<p>请查看文档<a href="https://help.aliyun.com/document_detail/113131.html" target="_blank" rel="noopener">数据探索</a>获得更多关于子查询的信息。</p>
<h1 id="为什么查询将epoch-0作为时间戳返回？"><a href="#为什么查询将epoch-0作为时间戳返回？" class="headerlink" title="为什么查询将epoch 0作为时间戳返回？"></a>为什么查询将epoch 0作为时间戳返回？</h1><p>在TSDB For InfluxDB®中，epoch 0（<code>1970-01-01T00:00:00Z</code>）通常用作空时间戳（null timestamp），如果您请求的查询中没有时间戳返回，例如，对于没有规定时间范围的聚合函数，TSDB For InfluxDB®返回epoch 0作为时间戳。</p>
<h1 id="哪些InfluxQL函数支持嵌套使用？"><a href="#哪些InfluxQL函数支持嵌套使用？" class="headerlink" title="哪些InfluxQL函数支持嵌套使用？"></a>哪些InfluxQL函数支持嵌套使用？</h1><p>以下InfluxQL函数支持嵌套使用：</p>
<ul>
<li><code>COUNT()</code>嵌套<code>DISTINCT()</code></li>
<li><code>CUMULATIVE_SUM()</code></li>
<li><code>DERIVATIVE()</code></li>
<li><code>DIFFERENCE()</code></li>
<li><code>ELAPSED()</code></li>
<li><code>MOVING_AVERAGE()</code></li>
<li><code>NON_NEGATIVE_DERIVATIVE()</code></li>
<li><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code></li>
</ul>
<p>关于如何使用子查询代替嵌套函数，请查看文档<a href="https://help.aliyun.com/document_detail/113131.html" target="_blank" rel="noopener">数据探索</a>。</p>
<h1 id="什么决定了GROUP-BY-time-查询返回的时间间隔？"><a href="#什么决定了GROUP-BY-time-查询返回的时间间隔？" class="headerlink" title="什么决定了GROUP BY time()查询返回的时间间隔？"></a>什么决定了<code>GROUP BY time()</code>查询返回的时间间隔？</h1><p><code>GROUP BY time()</code>查询返回的时间间隔符合TSDB For InfluxDB®的预设时间段或者符合用户指定的偏移间隔。</p>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><h3 id="预设时间段"><a href="#预设时间段" class="headerlink" title="预设时间段"></a>预设时间段</h3><p>以下查询计算<code>sunflowers</code>在6:15pm到7:45pm之间的平均值，并将这些平均值按一小时进行分组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT mean(&quot;sunflowers&quot;)FROM &quot;flower_orders&quot;WHERE time &gt;&#x3D; &#39;2016-08-29T18:15:00Z&#39; AND time &lt;&#x3D; &#39;2016-08-29T19:45:00Z&#39; GROUP BY time(1h)</span><br></pre></td></tr></table></figure>

<p>下面的结果展示了TSDB For InfluxDB®如何维护它的预设时间段。</p>
<p>在这个示例中，6pm是一个预设的时间段，7pm也是一个预设的时间段。由于<code>WHERE</code>子句中指定了查询的时间范围，所以在计算6pm时间段对应的平均值时不包括在6:15pm之前的数据，但是用于计算6pm时间段平均值的数据必须发生在6pm这个小时里。对于7pm时间段也是一样；用于计算7pm时间段平均值的数据必须发生在7pm这个小时里。虚线部分展示了用于计算每个平均值的数据点。</p>
<p>请注意，虽然结果中第一个时间戳是<code>2016-08-29T18:00:00Z</code>，但是在该时间段的查询结果不包含发生在<code>2016-08-29T18:15:00Z</code>（<code>WHERE</code>子句中指定的开始时间）之前的数据。</p>
<p>原始数据：                                                                                     结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: flower_orders                                name: flower_orders—————————                                          -------------------time                    sunflowers                 time                  mean2016-08-29T18:00:00Z    34                         2016-08-29T18:00:00Z  22.332                       |--|                        2016-08-29T19:00:00Z  62.752016-08-29T18:15:00Z   |28|2016-08-29T18:30:00Z   |19|2016-08-29T18:45:00Z   |20|                       |--|                       |--|2016-08-29T19:00:00Z   |56|2016-08-29T19:15:00Z   |76|2016-08-29T19:30:00Z   |29|2016-08-29T19:45:00Z   |90|                       |--|2016-08-29T20:00:00Z    70</span><br></pre></td></tr></table></figure>

<h3 id="偏移间隔"><a href="#偏移间隔" class="headerlink" title="偏移间隔"></a>偏移间隔</h3><p>以下查询计算<code>sunflowers</code>在6:15pm到7:45pm之间的平均值，并将这些平均值按一小时进行分组，同时，该查询还将TSDB For InfluxDB®的预设时间段偏移<code>15</code>分钟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT mean(&quot;sunflowers&quot;)FROM &quot;flower_orders&quot;WHERE time &gt;&#x3D; &#39;2016-08-29T18:15:00Z&#39; AND time &lt;&#x3D; &#39;2016-08-29T19:45:00Z&#39; GROUP BY time(1h,15m)                                                                                         ---                                                                                          |                                                                                  offset interval</span><br></pre></td></tr></table></figure>

<p>在这个示例中，用户指定的偏移间隔将TSDB For InfluxDB®的预设时间段前移了<code>15</code>分钟。现在，6pm时间段的平均值包括在6:15pm和7:15pm之间的数据，7pm时间段的平均值包括在7:15pm和8:15pm之间的数据。虚线部分展示了用于计算每个平均值的数据点。</p>
<p>请注意，现在结果中第一个时间戳是<code>2016-08-29T18:15:00Z</code>，而不是<code>2016-08-29T18:00:00Z</code>。</p>
<p>原始数据：                                                                                     结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: flower_orders                                name: flower_orders—————————                                          -------------------time                    sunflowers                 time                  mean2016-08-29T18:00:00Z    34                         2016-08-29T18:15:00Z  30.75                       |--|                        2016-08-29T19:15:00Z  652016-08-29T18:15:00Z   |28|2016-08-29T18:30:00Z   |19|2016-08-29T18:45:00Z   |20|2016-08-29T19:00:00Z   |56|                       |--|                       |--|2016-08-29T19:15:00Z   |76|2016-08-29T19:30:00Z   |29|2016-08-29T19:45:00Z   |90|2016-08-29T20:00:00Z   |70|                       |--|</span><br></pre></td></tr></table></figure>

<h1 id="为什么查询没有返回任何数据或者只返回一部分数据？"><a href="#为什么查询没有返回任何数据或者只返回一部分数据？" class="headerlink" title="为什么查询没有返回任何数据或者只返回一部分数据？"></a>为什么查询没有返回任何数据或者只返回一部分数据？</h1><p>对于为什么查询没有返回任何数据或者只返回一部分数据，有几种可能的解释。我们在下面列出了一些最常见的原因：</p>
<h2 id="保留策略"><a href="#保留策略" class="headerlink" title="保留策略"></a>保留策略</h2><p>第一个也是最常见的解释与保留策略（RP）有关。TSDB For InfluxDB®自动从数据库的默认（<code>DEFAULT</code>）RP中查询数据。如果您的数据不是存储在默认的RP，TSDB For InfluxDB®不会返回任何结果，除非您明确指定所使用的RP。</p>
<h2 id="SELECT子句中的tag-key"><a href="#SELECT子句中的tag-key" class="headerlink" title="SELECT子句中的tag key"></a>SELECT子句中的tag key</h2><p>在<code>SELECT</code>子句中，至少需要包含一个field key，查询才会返回数据。如果<code>SELECT</code>子句只包含一个或多个tag key，查询会返回空的结果。请查看文档<a href="https://help.aliyun.com/document_detail/113131.html" target="_blank" rel="noopener">数据探索</a>获得更多相关信息。</p>
<h2 id="查询时间范围"><a href="#查询时间范围" class="headerlink" title="查询时间范围"></a>查询时间范围</h2><p>另一个可能的解释与查询的时间范围有关。默认情况下，大多数<code>SELECT</code>查询涵盖在<code>1677-09-21 00:12:43.145224194</code>UTC和<code>2262-04-11T23:47:16.854775806Z</code> UTC之间的时间范围。<code>SELECT</code>查询还包括<code>GROUP BY time()</code>子句，但是，它涵盖的时间范围在<code>1677-09-21 00:12:43.145224194</code>和<code>now()</code>之间。如果您的数据发生在<code>now()</code>之后，那么<code>GROUP BY time()</code>查询不会覆盖这些发生在<code>now()</code>之后的数据。如果查询语句包括<code>GROUP BY time()</code>子句，并且有数据发生在<code>now()</code>之后，您需要为时间范围提供一个上限。</p>
<h2 id="标识符名字"><a href="#标识符名字" class="headerlink" title="标识符名字"></a>标识符名字</h2><p>最后一个常见的解释与schema有关（field和tag有相同的名字）。如果field key和tag key相同，那么在所有查询中优先考虑field。在查询中，你需要使用<code>::tag</code>语法指定tag key。</p>
<h1 id="为什么GROUP-BY-time-查询不返回发生在now-之后的时间戳？"><a href="#为什么GROUP-BY-time-查询不返回发生在now-之后的时间戳？" class="headerlink" title="为什么GROUP BY time()查询不返回发生在now()之后的时间戳？"></a>为什么<code>GROUP BY time()</code>查询不返回发生在<code>now()</code>之后的时间戳？</h1><p>大多数<code>SELECT</code>语句的默认时间范围在<code>1677-09-21 00:12:43.145224194 UTC</code>和<code>2262-04-11T23:47:16.854775806Z UTC</code>之间。对于带<code>GROUP BY time()</code>子句的<code>SELECT</code>语句，默认的时间范围在<code>1677-09-21 00:12:43.145224194</code>和<code>now()</code>之间。</p>
<p>如果要查询时间戳发生在<code>now()</code>之后的数据，带<code>GROUP BY time()</code>子句的<code>SELECT</code>语句必须在<code>WHERE</code>子句中提供一个时间上限。</p>
<p>在下面的示例中，第一个查询涵盖时间戳在<code>2015-09-18T21:30:00Z</code>和<code>now()</code>之间的数据，第二个查询涵盖时间戳在<code>2015-09-18T21:30:00Z</code>和<code>now()</code>之后180个星期之间的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MEAN(&quot;boards&quot;) FROM &quot;hillvalley&quot; WHERE time &gt;&#x3D; &#39;2015-09-18T21:30:00Z&#39; GROUP BY time(12m) fill(none)&gt; SELECT MEAN(&quot;boards&quot;) FROM &quot;hillvalley&quot; WHERE time &gt;&#x3D; &#39;2015-09-18T21:30:00Z&#39; AND time &lt;&#x3D; now() + 180w GROUP BY time(12m) fill(none)</span><br></pre></td></tr></table></figure>

<p>请注意，<code>WHERE</code>子句必须提供一个时间上线来覆盖默认的<code>now()</code>上限。下面的查询只是将<code>now()</code>的下限重置，使得查询的时间范围在<code>now()</code>和<code>now()</code>之间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MEAN(&quot;boards&quot;) FROM &quot;hillvalley&quot; WHERE time &gt;&#x3D; now() GROUP BY time(12m) fill(none)&gt;</span><br></pre></td></tr></table></figure>

<p>请查看文档<a href="https://help.aliyun.com/document_detail/113131.html" target="_blank" rel="noopener">数据探索</a>获得更多关于时间语法的信息。</p>
<h1 id="是否可以对时间戳执行数学运算？"><a href="#是否可以对时间戳执行数学运算？" class="headerlink" title="是否可以对时间戳执行数学运算？"></a>是否可以对时间戳执行数学运算？</h1><p>目前，在TSDB For InfluxDB®中，不能对时间戳执行数学运算。更多关于时间的计算必须由接收查询结果的客户端执行。</p>
<p>对时间戳使用InfluxQL函数，TSDB For InfluxDB®仅提供有限的支持。ELAPSED()函数返回单个field中时间戳之间的差值。</p>
<h1 id="是否可以从返回的时间戳中识别写入精度？"><a href="#是否可以从返回的时间戳中识别写入精度？" class="headerlink" title="是否可以从返回的时间戳中识别写入精度？"></a>是否可以从返回的时间戳中识别写入精度？</h1><p>不管提供的写入精度是多少，TSDB For InfluxDB®将所有时间戳存储为纳秒。需要注意的一个重要事项是，当返回查询结果时，数据库会不动声色地删除时间戳后面的零，使原始的写入精度很难识别。</p>
<p>在下面的示例中，tag <code>precision_supplied</code>和<code>timestamp_supplied</code>分别显示了用户在写入数据时提供的时间精度和时间戳。因为TSDB For InfluxDB®默默地将返回的时间戳后面的零删除了，所以从返回的时间戳中很难识别写入精度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: trails-------------time                  value  precision_supplied  timestamp_supplied1970-01-01T01:00:00Z  3      n                   36000000000001970-01-01T01:00:00Z  5      h                   11970-01-01T02:00:00Z  4      n                   72000000000001970-01-01T02:00:00Z  6      h                   2</span><br></pre></td></tr></table></figure>

<h1 id="当查询数据时，什么时候应该使用单引号，什么时候应该使用双引号？"><a href="#当查询数据时，什么时候应该使用单引号，什么时候应该使用双引号？" class="headerlink" title="当查询数据时，什么时候应该使用单引号，什么时候应该使用双引号？"></a>当查询数据时，什么时候应该使用单引号，什么时候应该使用双引号？</h1><p>用单引号将字符串类型的值括起来（例如，tag value），但是不要用单引号将标识符（数据库名字、保留策略名字、用户名、measurement的名字、tag key和field key）括起来。</p>
<p>如果标识符以数字开头，或包含除<code>[A-z,0-9,_]</code>外的字符，或者标识符是InfluxQL关键字，那么需要使用双引号将标识符括起来。如果标识符不属于这些类别之一，可以不需要使用双引号将它们括起来，但是我们还是建议用双引号将它们括起来。</p>
<p>示例：</p>
<p>合法的查询：<code>SELECT bikes_available FROM bikes WHERE station_id=&#39;9&#39;</code></p>
<p>合法的查询：<code>SELECT &quot;bikes_available&quot; FROM &quot;bikes&quot; WHERE &quot;station_id&quot;=&#39;9&#39;</code></p>
<p>合法的查询：<code>SELECT MIN(&quot;avgrq-sz&quot;) AS &quot;min_avgrq-sz&quot; FROM telegraf</code></p>
<p>合法的查询：<code>SELECT * from &quot;cr@zy&quot; where &quot;p^e&quot;=&#39;2&#39;</code></p>
<p>非法的查询：<code>SELECT &#39;bikes_available&#39; FROM &#39;bikes&#39; WHERE &#39;station_id&#39;=&quot;9&quot;</code></p>
<p>非法的查询：<code>SELECT * from cr@zy where p^e=&#39;2&#39;</code></p>
<p>用单引号将日期时间字符串括起来。如果您使用双引号将日期时间字符串括起来，TSDB For InfluxDB®会返回错误（<code>ERR: invalid operation: time and *influxql.VarRef are not compatible</code>）。</p>
<p>示例：</p>
<p>合法的查询：<code>SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt; &#39;2015-08-18T23:00:01.232000000Z&#39; AND time &lt; &#39;2015-09-19&#39;</code></p>
<p>非法的查询：<code>SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt; &quot;2015-08-18T23:00:01.232000000Z&quot; AND time &lt; &quot;2015-09-19&quot;</code></p>
<p>请查看文档<a href="https://help.aliyun.com/document_detail/113131.html" target="_blank" rel="noopener">数据探索</a>获得更多关于时间语法的信息。</p>
<h1 id="为什么在创建一个新的默认（DEFAULT）保留策略后会丢失数据？"><a href="#为什么在创建一个新的默认（DEFAULT）保留策略后会丢失数据？" class="headerlink" title="为什么在创建一个新的默认（DEFAULT）保留策略后会丢失数据？"></a>为什么在创建一个新的默认（<code>DEFAULT</code>）保留策略后会丢失数据？</h1><p>当您在数据库中创建一个新的默认保留策略（RP）后，在旧的默认RP中的数据依旧保存在旧的RP中。对于不指定RP的查询，将会自动查询新默认RP中的数据，所有旧数据可能会丢失。为了查询旧数据，必须完全限定查询中的数据。</p>
<p>示例：</p>
<p>在measurement <code>fleeting</code>中的所有数据属于默认的RP，该RP的名字为<code>one_hour</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT count(flounders) FROM fleetingname: fleeting--------------time                     count1970-01-01T00:00:00Z     8</span><br></pre></td></tr></table></figure>

<p>现在我们创建一个新的默认RP（<code>two_hour</code>），并执行相同的查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT count(flounders) FROM fleeting&gt;</span><br></pre></td></tr></table></figure>

<p>为了查询旧数据，我们必须通过完全限定<code>fleeting</code>来指定旧的默认RP：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT count(flounders) FROM fish.one_hour.fleetingname: fleeting--------------time                     count1970-01-01T00:00:00Z     8</span><br></pre></td></tr></table></figure>

<h1 id="为什么带有WHERE-OR时间子句的查询返回空结果？"><a href="#为什么带有WHERE-OR时间子句的查询返回空结果？" class="headerlink" title="为什么带有WHERE OR时间子句的查询返回空结果？"></a>为什么带有<code>WHERE OR</code>时间子句的查询返回空结果？</h1><p>目前，TSDB For InfluxDB®不支持在<code>WHERE</code>子句中使用<code>OR</code>来指定多个时间范围。如果查询中的<code>WHERE</code>子句使用<code>OR</code>来指定多个时间范围，那么TSDB For InfluxDB®不会返回任何结果。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM &quot;absolutismus&quot; WHERE time &#x3D; &#39;2016-07-31T20:07:00Z&#39; OR time &#x3D; &#39;2016-07-31T23:07:17Z&#39;&gt;</span><br></pre></td></tr></table></figure>

<h1 id="为什么fill-previous-返回空结果？"><a href="#为什么fill-previous-返回空结果？" class="headerlink" title="为什么fill(previous)返回空结果？"></a>为什么<code>fill(previous)</code>返回空结果？</h1><p>如果前一个值在查询的时间范围之外，那么<code>fill(previous)</code>不会填充该时间段的值。</p>
<p>在下面的示例中，TSDB For InfluxDB®不会使用时间段<code>2016-07-12T16:50:00Z</code>-<code>2016-07-12T16:50:10Z</code>的值填充时间段<code>2016-07-12T16:50:20Z</code>-<code>2016-07-12T16:50:30Z</code>，因为该查询的时间范围并不包含较早的时间段。</p>
<p>原始数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM &quot;cupcakes&quot;name: cupcakes--------------time                   chocolate2016-07-12T16:50:00Z   32016-07-12T16:50:10Z   22016-07-12T16:50:40Z   122016-07-12T16:50:50Z   11</span><br></pre></td></tr></table></figure>

<p><code>GROUP BY time()</code>查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT max(&quot;chocolate&quot;) FROM &quot;cupcakes&quot; WHERE time &gt;&#x3D; &#39;2016-07-12T16:50:20Z&#39; AND time &lt;&#x3D; &#39;2016-07-12T16:51:10Z&#39; GROUP BY time(20s) fill(previous)name: cupcakes--------------time                   max2016-07-12T16:50:20Z2016-07-12T16:50:40Z   122016-07-12T16:51:00Z   12</span><br></pre></td></tr></table></figure>

<h1 id="为什么INTO查询会丢失数据？"><a href="#为什么INTO查询会丢失数据？" class="headerlink" title="为什么INTO查询会丢失数据？"></a>为什么<code>INTO</code>查询会丢失数据？</h1><p>默认情况下，<code>INTO</code>查询将原始数据中的tag转换成新写入数据的field。这会导致TSDB For InfluxDB®覆盖之前由tag区分的数据点。在所有<code>INTO</code>查询中加上<code>GROUP BY *</code>，可以将tag保留在新写入的数据中。</p>
<p>请注意，这种方式不适用于使用<code>TOP()</code>或<code>BOTTOM()</code>函数的查询。请查看文档<a href="https://help.aliyun.com/document_detail/113126.html" target="_blank" rel="noopener">InfluxQL函数</a>获得更多关于<code>TOP()</code>和<code>BOTTOM()</code>的信息。</p>
<h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><h3 id="原始数据"><a href="#原始数据" class="headerlink" title="原始数据"></a>原始数据</h3><p>measurement <code>french_bulldogs</code>包含一个tag <code>color</code>和一个field <code>name</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM &quot;french_bulldogs&quot;name: french_bulldogs---------------------time                  color  name2016-05-25T00:05:00Z  peach  nugget2016-05-25T00:05:00Z  grey   rumple2016-05-25T00:10:00Z  black  prince</span><br></pre></td></tr></table></figure>

<h3 id="不使用GROUP-BY-的INTO查询"><a href="#不使用GROUP-BY-的INTO查询" class="headerlink" title="不使用GROUP BY *的INTO查询"></a>不使用<code>GROUP BY *</code>的<code>INTO</code>查询</h3><p>不使用<code>GROUP BY *</code>子句的<code>INTO</code>查询将tag <code>color</code>转换成新写入数据中的field。在原始数据中，数据点<code>nugget</code>和<code>rumple</code>仅由tag <code>color</code>区分。一旦<code>color</code>变成field，TSDB For InfluxDB®会认为数据点<code>nugget</code>和<code>rumple</code>是重复的，它会用数据点<code>rumple</code>将数据点<code>nugget</code>覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * INTO &quot;all_dogs&quot; FROM &quot;french_bulldogs&quot;name: result------------time                  written1970-01-01T00:00:00Z  3&gt; SELECT * FROM &quot;all_dogs&quot;name: all_dogs--------------time                  color  name2016-05-25T00:05:00Z  grey   rumple                &lt;---- no more nugget2016-05-25T00:10:00Z  black  prince</span><br></pre></td></tr></table></figure>

<h3 id="使用GROUP-BY-的INTO查询"><a href="#使用GROUP-BY-的INTO查询" class="headerlink" title="使用GROUP BY *的INTO查询"></a>使用<code>GROUP BY *</code>的<code>INTO</code>查询</h3><p>使用<code>GROUP BY *</code>子句的<code>INTO</code>查询将tag <code>color</code>保留在新写入的数据中。在这种情况下，数据点<code>nugget</code>和<code>rumple</code>依旧是不同的数据点，TSDB For InfluxDB®不会覆盖任何数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT &quot;name&quot; INTO &quot;all_dogs&quot; FROM &quot;french_bulldogs&quot; GROUP BY *name: result------------time                  written1970-01-01T00:00:00Z  3&gt; SELECT * FROM &quot;all_dogs&quot;name: all_dogs--------------time                  color  name2016-05-25T00:05:00Z  peach  nugget2016-05-25T00:05:00Z  grey   rumple2016-05-25T00:10:00Z  black  prince</span><br></pre></td></tr></table></figure>

<h1 id="如何查询tag-key和field-key名字相同的数据？"><a href="#如何查询tag-key和field-key名字相同的数据？" class="headerlink" title="如何查询tag key和field key名字相同的数据？"></a>如何查询tag key和field key名字相同的数据？</h1><p>使用语法<code>::</code>指定一个key是field key还是tag key。</p>
<h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><h3 id="示例数据："><a href="#示例数据：" class="headerlink" title="示例数据："></a>示例数据：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; INSERT candied,almonds&#x3D;true almonds&#x3D;50,half_almonds&#x3D;51 1465317610000000000&gt; INSERT candied,almonds&#x3D;true almonds&#x3D;55,half_almonds&#x3D;56 1465317620000000000&gt; SELECT * FROM &quot;candied&quot;name: candied-------------time                   almonds  almonds_1  half_almonds2016-06-07T16:40:10Z   50       true       512016-06-07T16:40:20Z   55       true       56</span><br></pre></td></tr></table></figure>

<h3 id="指定key是field："><a href="#指定key是field：" class="headerlink" title="指定key是field："></a>指定key是field：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM &quot;candied&quot; WHERE &quot;almonds&quot;::field &gt; 51name: candied-------------time                   almonds  almonds_1  half_almonds2016-06-07T16:40:20Z   55       true       56</span><br></pre></td></tr></table></figure>

<h3 id="指定key是tag："><a href="#指定key是tag：" class="headerlink" title="指定key是tag："></a>指定key是tag：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM &quot;candied&quot; WHERE &quot;almonds&quot;::tag&#x3D;&#39;true&#39;name: candied-------------time                   almonds  almonds_1  half_almonds2016-06-07T16:40:10Z   50       true       512016-06-07T16:40:20Z   55       true       56</span><br></pre></td></tr></table></figure>

<h1 id="如何跨measurement查询数据？"><a href="#如何跨measurement查询数据？" class="headerlink" title="如何跨measurement查询数据？"></a>如何跨measurement查询数据？</h1><p>目前，无法跨measurement执行数学运算或分组。所有数据必须在同一个measurement下，才能一起查询这些数据。TSDB For InfluxDB®不是一个关系型数据库，跨measurement映射数据目前不是一个推荐的schema。</p>
<h1 id="时间戳的顺序是否重要？"><a href="#时间戳的顺序是否重要？" class="headerlink" title="时间戳的顺序是否重要？"></a>时间戳的顺序是否重要？</h1><p>不重要。测试结果表明TSDB For InfluxDB®完成以下查询所需的时间差别非常小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM ... WHERE time &gt; &#39;timestamp1&#39; AND time &lt; &#39;timestamp2&#39;SELECT ... FROM ... WHERE time &lt; &#39;timestamp2&#39; AND time &gt; &#39;timestamp1&#39;</span><br></pre></td></tr></table></figure>

<h1 id="如何SELECT有tag但没有tag-value的数据？"><a href="#如何SELECT有tag但没有tag-value的数据？" class="headerlink" title="如何SELECT有tag但没有tag value的数据？"></a>如何<code>SELECT</code>有tag但没有tag value的数据？</h1><p>使用<code>&#39;&#39;</code>指定一个空的tag value。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM &quot;vases&quot; WHERE priceless&#x3D;&#39;&#39;name: vases-----------time                   origin   priceless2016-07-20T18:42:00Z   8</span><br></pre></td></tr></table></figure>

<h1 id="为什么序列基数很重要？"><a href="#为什么序列基数很重要？" class="headerlink" title="为什么序列基数很重要？"></a>为什么序列基数很重要？</h1><p>TSDB For InfluxDB®维护系统中每个序列在内存中的索引。随着序列数量不断增加，RAM（内存）使用量也在不断增加。序列基数过大会导致操作系统终止TSDB For InfluxDB®进程，并抛出内存不足（OOM）异常。请查看文档<a href="https://help.aliyun.com/document_detail/113127.html" target="_blank" rel="noopener">InfluxQL参考</a>了解关于序列基数的InfluxQL命令。</p>
<h1 id="如何写入整型的field-value？"><a href="#如何写入整型的field-value？" class="headerlink" title="如何写入整型的field value？"></a>如何写入整型的field value？</h1><p>当写入整数时，在field value末尾加上<code>i</code>。如果您不加上<code>i</code>，TSDB For InfluxDB®会把field value当作浮点数。</p>
<p>写入整数：<code>value=100i</code><br>写入浮点数：<code>value=100</code></p>
<h1 id="TSDB-For-InfluxDB®如何处理重复数据点？"><a href="#TSDB-For-InfluxDB®如何处理重复数据点？" class="headerlink" title="TSDB For InfluxDB®如何处理重复数据点？"></a>TSDB For InfluxDB®如何处理重复数据点？</h1><p>measurement的名字、tag set和时间戳唯一标识一个数据点。如果您提交的数据点跟已有的数据点相比，具有相同measurement、tag set和时间戳，但具有不同field set，那么该数据点的field set会变为旧field set和新field set的并集，如果有任何冲突以新field set为准。这是预期的结果。</p>
<p>例如：</p>
<p>旧数据点：<code>cpu_load,hostname=server02,az=us_west val_1=24.5,val_2=7 1234567890000000</code></p>
<p>新数据点：<code>cpu_load,hostname=server02,az=us_west val_1=5.24 1234567890000000</code></p>
<p>当您提交新数据点后，TSDB For InfluxDB®使用新的field value覆盖<code>val_1</code>的值，<code>val_2</code>的值继续保留：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM &quot;cpu_load&quot; WHERE time &#x3D; 1234567890000000name: cpu_load--------------time                      az        hostname   val_1   val_21970-01-15T06:56:07.89Z   us_west   server02   5.24    7</span><br></pre></td></tr></table></figure>

<p>为了存储这两个数据点，可以：</p>
<ul>
<li><p>引入新的tag保证唯一性。</p>
<p>旧数据点：<code>cpu_load,hostname=server02,az=us_west,uniq=1 val_1=24.5,val_2=7 1234567890000000</code></p>
<p>新数据点：<code>cpu_load,hostname=server02,az=us_west,uniq=2 val_1=5.24 1234567890000000</code></p>
<p>将新数据点写入TSDB For InfluxDB®后：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM &quot;cpu_load&quot; WHERE time &#x3D; 1234567890000000name: cpu_load--------------time                      az        hostname   uniq   val_1   val_21970-01-15T06:56:07.89Z   us_west   server02   1      24.5    71970-01-15T06:56:07.89Z   us_west   server02   2      5.24</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间戳增加一纳秒。</p>
<p>旧数据点：<code>cpu_load,hostname=server02,az=us_west val_1=24.5,val_2=7 1234567890000000</code></p>
<p>新数据点：<code>cpu_load,hostname=server02,az=us_west val_1=5.24 1234567890000001</code></p>
<p>将新数据点写入TSDB For InfluxDB®后：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM &quot;cpu_load&quot; WHERE time &gt;&#x3D; 1234567890000000 and time &lt;&#x3D; 1234567890000001name: cpu_load--------------time                             az        hostname   val_1   val_21970-01-15T06:56:07.89Z          us_west   server02   24.5    71970-01-15T06:56:07.890000001Z   us_west   server02   5.24</span><br></pre></td></tr></table></figure>

<h1 id="HTTP-API需要怎样的换行符？"><a href="#HTTP-API需要怎样的换行符？" class="headerlink" title="HTTP API需要怎样的换行符？"></a>HTTP API需要怎样的换行符？</h1><p>TSDB For InfluxDB®的行协议依赖换行符（<code>\n</code>，这是ASCII <code>0x0A</code>）来表示一行的结束和新的一行的开始。文件或数据使用<code>\n</code>以外的换行符会导致以下错误：<code>bad timestamp</code>, <code>unable to parse</code>。</p>
<p>请注意，Windows使用回车键和换行符（<code>\r\n</code>）作为换行符。</p>
<h1 id="当将数据写入TSDB-For-InfluxDB®时，应该避免哪些文字和字符？"><a href="#当将数据写入TSDB-For-InfluxDB®时，应该避免哪些文字和字符？" class="headerlink" title="当将数据写入TSDB For InfluxDB®时，应该避免哪些文字和字符？"></a>当将数据写入TSDB For InfluxDB®时，应该避免哪些文字和字符？</h1><h2 id="InfluxQL关键字"><a href="#InfluxQL关键字" class="headerlink" title="InfluxQL关键字"></a>InfluxQL关键字</h2><p>如果您使用InfluxQL关键字作为标识符，您需要在每个查询中使用双引号将该标识符括起来。如果不使用双引号，会导致错误。标识符是连续查询名字、数据库名字、field key、measurement的名字、保留策略名字、tag key和用户名。</p>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>关键字<code>time</code>是一个特例。<code>time</code>可以是一个连续查询名字、数据库名字、measurement的名字、保留策略名字和用户名。在这些情况下，不需要在查询中用双引号将<code>time</code>括起来。<code>time</code>不能是field key或tag key；TSDB For InfluxDB®拒绝写入将<code>time</code>作为field key或tag key的数据，对于这种数据写入，TSDB For InfluxDB®会返回错误。</p>
<h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><h4 id="将time作为measurement，写入数据并查询它"><a href="#将time作为measurement，写入数据并查询它" class="headerlink" title="将time作为measurement，写入数据并查询它"></a>将<code>time</code>作为measurement，写入数据并查询它</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; INSERT time value&#x3D;1&gt; SELECT * FROM timename: timetime                            value----                            -----2017-02-07T18:28:27.349785384Z  1</span><br></pre></td></tr></table></figure>

<p>在TSDB For InfluxDB®中，<code>time</code>是一个有效的measurement名字。</p>
<h4 id="将time作为field-key，写入数据并尝试查询它"><a href="#将time作为field-key，写入数据并尝试查询它" class="headerlink" title="将time作为field key，写入数据并尝试查询它"></a>将<code>time</code>作为field key，写入数据并尝试查询它</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; INSERT mymeas time&#x3D;1ERR: &#123;&quot;error&quot;:&quot;partial write: invalid field name: input field \&quot;time\&quot; on measurement \&quot;mymeas\&quot; is invalid dropped&#x3D;1&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>在TSDB For InfluxDB®中，<code>time</code>不是一个有效的field key。系统无法写入该数据点，并且返回<code>400</code>错误。</p>
<h4 id="将time作为tag-key，写入数据并尝试查询它"><a href="#将time作为tag-key，写入数据并尝试查询它" class="headerlink" title="将time作为tag key，写入数据并尝试查询它"></a>将<code>time</code>作为tag key，写入数据并尝试查询它</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; INSERT mymeas,time&#x3D;1 value&#x3D;1ERR: &#123;&quot;error&quot;:&quot;partial write: invalid tag key: input tag \&quot;time\&quot; on measurement \&quot;mymeas\&quot; is invalid dropped&#x3D;1&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>在TSDB For InfluxDB®中，<code>time</code>不是一个有效的tag key。系统无法写入该数据点，并且返回<code>400</code>错误。</p>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>为了保持简单的正则表达式和引号，避免在标识符中使用以下字符：<br><code>\</code> 反斜杠<br><code>^</code> 尖号<br><code>$</code> 货币符号<br><code>&#39;</code> 单引号<br><code>&quot;</code> 双引号<br><code>=</code> 等号<br><code>,</code> 逗号</p>
<h1 id="当写入数据时，什么时候应该使用单引号，什么时候应该使用双引号？"><a href="#当写入数据时，什么时候应该使用单引号，什么时候应该使用双引号？" class="headerlink" title="当写入数据时，什么时候应该使用单引号，什么时候应该使用双引号？"></a>当写入数据时，什么时候应该使用单引号，什么时候应该使用双引号？</h1><ul>
<li><p>通过行协议写入数据时，避免使用单引号和双引号将标识符括起来；请查看下面的示例，使用引号后的标识符会使查询变得复杂。标识符是连续查询名字、数据库名字、field key、measurement的名字、保留策略名字、subscription的名字、tag key和用户名。</p>
<p>写入带双引号的measurement：<code>INSERT &quot;bikes&quot; bikes_available=3</code><br>适用的查询：<code>SELECT * FROM &quot;\&quot;bikes\&quot;&quot;</code></p>
<p>写入带单引号的measurement：<code>INSERT &#39;bikes&#39; bikes_available=3</code><br>适用的查询：<code>SELECT * FROM &quot;\&#39;bikes\&#39;&quot;</code></p>
<p>写入不带引号的measurement：<code>INSERT bikes bikes_available=3</code><br>适用的查询：<code>SELECT * FROM &quot;bikes&quot;</code></p>
</li>
<li><p>用双引号将字符串类型的field value括起来。</p>
<p>写入：<code>INSERT bikes happiness=&quot;level 2&quot;</code><br>适用的查询：<code>SELECT * FROM &quot;bikes&quot; WHERE &quot;happiness&quot;=&#39;level 2&#39;</code></p>
</li>
<li><p>应该用反斜杠转义特殊字符，而不是用引号将其括起来。</p>
<p>写入：<code>INSERT wacky va\&quot;ue=4</code><br>适用的查询：<code>SELECT &quot;va\&quot;ue&quot; FROM &quot;wacky&quot;</code></p>
</li>
</ul>
<p>请查看文档<a href="https://help.aliyun.com/document_detail/113118.html" target="_blank" rel="noopener">行协议参考</a>获得更多相关信息。</p>
<h1 id="时间戳的精度是否重要？"><a href="#时间戳的精度是否重要？" class="headerlink" title="时间戳的精度是否重要？"></a>时间戳的精度是否重要？</h1><p>重要。为了最大限度地提高性能，向TSDB For InfluxDB®写入数据时尽量使用最粗糙的时间精度。</p>
<p>在下面两个例子中，第一个请求使用默认精度(纳秒)，而第二个请求将精度设置为秒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XPOST &quot;https:&#x2F;&#x2F;&lt;网络地址&gt;:3242&#x2F;write?db&#x3D;weather&amp;u&#x3D;&lt;账号名称&gt;&amp;p&#x3D;&lt;密码&gt;&quot; --data-binary &#39;temperature,location&#x3D;1 value&#x3D;90 1472666050000000000&#39;curl -i -XPOST &quot;https:&#x2F;&#x2F;&lt;网络地址&gt;:3242&#x2F;write?db&#x3D;weather&amp;precision&#x3D;s&amp;u&#x3D;&lt;账号名称&gt;&amp;p&#x3D;&lt;密码&gt;&quot; --data-binary &#39;temperature,location&#x3D;1 value&#x3D;90 1472666050&#39;</span><br></pre></td></tr></table></figure>

<p>虽然性能会提高，但是代价是精度越粗糙，越有可能出现具有相同时间戳的重复数据点，可能会覆盖其它数据点。</p>
<p>InfluxDB® is a trademark registered by InfluxData, which is not affiliated with, and does not endorse, TSDB for InfluxDB®.</p>
 
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://imonster.me/2019/10/16/influxdb%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-influxdb/" rel="tag">数据库\influxdb</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2019/10/24/pod%E8%AF%A6%E8%A7%A3/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            pod详解
          
        </div>
      </a>
    
    
      <a href="/2019/10/15/flink%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">flink支持的数据类型</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "P8UW8TGMAGhyQQwHvEapAIFU-gzGzoHsz",
    app_key: "5DrCaQB8SC2oKR5zUFbNSGUs",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2018-2020
        <i class="ri-heart-fill heart_icon"></i> 丁振莹
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://v1.cnzz.com/z_stat.php?id=1279045202&amp;web_id=1279045202'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="iMonster"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.png">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 50,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>